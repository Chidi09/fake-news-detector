<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Fake News Detection System</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    <!-- Chart.js CDN for Sentiment Graph -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Firebase SDKs for Firestore and Auth -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged,
            signOut // Only signOut is needed here now
        } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, doc, getDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

        // Your web app's Firebase configuration (MUST BE THE SAME AS auth.html)
        const firebaseConfig = {
            apiKey: "AIzaSyAzxIOsaM2smH6Xx5XTyP8PMHZF1SloV8k",
            authDomain: "fakenewsdetector-a29bd.firebaseapp.com",
            projectId: "fakenewsdetector-a29bd",
            storageBucket: "fakenewsdetector-a29bd.firebasestorage.app",
            messagingSenderId: "547697866883",
            appId: "1:547697866883:web:307b464c8d8b0e40acc3b6",
            measurementId: "G-F05HJ0B35J"
        };
        const appId = firebaseConfig.appId; // Use the appId from your config

        // Expose firebaseConfig globally so other scripts can access it (if needed by other files)
        window.firebaseConfig = firebaseConfig; 

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        let userId = 'anonymous'; // Default to anonymous
        let userPoints = 0; // Initialize user points

        // Function to display a custom message box
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.className = 'fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 message-box';
            messageBox.innerHTML = `
                <div class="bg-white p-8 rounded-xl shadow-2xl text-center message-box-content">
                    <p class="text-2xl font-bold text-gray-800 mb-6">${message}</p>
                    <button class="btn btn-primary" onclick="this.parentElement.parentElement.remove()">Got It!</button>
                </div>
            `;
            document.body.appendChild(messageBox);
        }

        // Initialize Chart.js instance outside the event listener
        let sentimentChart;

        // Function to update sentiment graph
        function updateSentimentGraph(sentimentData) {
            const ctx = document.getElementById('mySentimentChart').getContext('2d');

            if (sentimentChart) {
                sentimentChart.destroy(); // Destroy existing chart before creating a new one
            }

            sentimentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: ['Past', 'Recent', 'Current'], // Simplified labels for simulation
                    datasets: [{
                        label: 'Sentiment Score',
                        data: sentimentData,
                        borderColor: '#4a4a4a', // Muted line color
                        backgroundColor: 'rgba(74, 74, 74, 0.2)', // Muted fill color
                        borderWidth: 2,
                        tension: 0.3, // Smooth curve
                        pointBackgroundColor: '#36454F',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false,
                        },
                        title: {
                            display: true,
                            text: 'Sentiment Change Over Time (Simulated)',
                            color: '#36454F', // Charcoal title
                            font: {
                                family: 'Inter',
                                size: 16,
                                weight: 'bold'
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false,
                            },
                            ticks: {
                                color: '#666', // Muted tick color
                                font: {
                                    family: 'Inter'
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: '#e0e0e0', // Lighter grid lines
                            },
                            ticks: {
                                color: '#666', // Muted tick color
                                font: {
                                    family: 'Inter'
                                }
                            }
                        }
                    }
                }
            });
        }


        // Function to call Gemini API for text analysis (Explainable AI Auditor, Propaganda)
        async function analyzeTextWithGemini(text) {
            let chatHistory = [];
            // Prompt for Explainable AI Auditor and Propaganda Pattern Recognizer
            chatHistory.push({ role: "user", parts: [{ text: `Analyze the following news article text for potential misinformation, emotional language, logical fallacies, or deceptive patterns.
            
            Provide a concise explanation of *why* it might be considered misleading or biased, highlighting specific phrases or characteristics.
            
            Then, identify any specific propaganda techniques used.
            
            Format your response clearly as two distinct sections:
            
            Deep Dive Analysis: [Your detailed explanation here, including specific examples from the text.]
            
            Propaganda Patterns Detected: [List of identified propaganda techniques, e.g., "Ad Hominem", "Cherry-Picking", "False Dilemma". If none, state "None identified." If the text is too short or lacks sufficient content for analysis, state "Insufficient content for detailed analysis." If the text is factual and unbiased, state "No significant misinformation or propaganda detected."]
            
            News Article Text:
            "${text}"` }] });

            const payload = { contents: chatHistory };
            // Use the API key from firebaseConfig (now directly accessible in this module scope)
            const apiKey = firebaseConfig.apiKey; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error('Gemini API HTTP Error (Analyze):', response.status, errorBody);
                    return `Error: API request failed with status ${response.status}. Details: ${errorBody.error?.message || JSON.stringify(errorBody)}`;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const analysisText = result.candidates[0].content.parts[0].text;
                    return analysisText;
                } else {
                    console.error('Gemini API response structure unexpected (Analyze):', result);
                    console.error('Full unexpected Gemini API result (Analyze):', result);
                    return 'Error: Could not get analysis from AI. The AI response structure was unexpected.';
                }
            } catch (error) {
                console.error('Error calling Gemini API (Analyze):', error);
                return `Error: Failed to connect to AI analysis service. Please check your network connection or try again later.`;
            }
        }

        // Function to call Gemini API for Counter-Narrative Generation
        async function generateCounterNarrative(originalText, analysis) {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: `Based on the following news article text and its analysis for misinformation/propaganda, generate a neutral, factual counter-narrative. Focus on presenting verified, unbiased information that addresses the misleading aspects without being confrontational. If the original text was mostly factual, state that it appears balanced.
            
            Original Article Text:
            "${originalText}"
            
            Analysis:
            "${analysis}"
            
            Counter-Narrative:` }] });

            const payload = { contents: chatHistory };
            // Use the API key from firebaseConfig (now directly accessible in this module scope)
            const apiKey = firebaseConfig.apiKey; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error('Gemini API HTTP Error (Counter-Narrative):', response.status, errorBody);
                    return `Error generating counter-narrative: API request failed with status ${response.status}.`;
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error('Gemini API response structure unexpected (Counter-Narrative):', result);
                    return 'Error: Could not generate counter-narrative.';
                }
            } catch (error) {
                console.error('Error calling Gemini API (Counter-Narrative):', error);
                return `Error: Failed to generate counter-narrative.`;
            }
        }

        // Function to call Gemini API for AI-Generated Text Detection (Enhanced Output)
        async function detectAIText(text) {
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: `Analyze the following text for patterns indicative of AI generation. Provide a concise assessment, including a confidence level (e.g., "Low", "Medium", "High") and a brief reason for your assessment (e.g., "Repetitive phrasing", "Overly generic language", "Lacks human-like nuance").
            
            Format your response as:
            Assessment: [Your assessment, e.g., "Potential AI-Generated Text Detected."]
            Confidence: [Confidence level, e.g., "High"]
            Reason: [Brief reason, e.g., "Repetitive sentence structures and formal tone."]
            
            If it appears human-written, state "Text appears human-written." and "Confidence: High" and "Reason: Natural language flow and varied expression."
            
            Text for analysis:
            "${text}"` }] });

            const payload = { contents: chatHistory };
            // Use the API key from firebaseConfig (now directly accessible in this module scope)
            const apiKey = firebaseConfig.apiKey; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error('Gemini API HTTP Error (AI Detect):', response.status, errorBody);
                    return `Error detecting AI text: API request failed with status ${response.status}.`;
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    console.error('Gemini API response structure unexpected (AI Detect):', result);
                    return 'Error: Could not detect AI text.';
                }
            } catch (error) {
                console.error('Error calling Gemini API (AI Detect):', error);
                return `Error: Failed to detect AI text.`;
            }
        }

        // Function to simulate Google Search results
        async function performGoogleSearch(query) {
            // Simulate a network delay
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Generate some dummy search results based on the query
            const dummyResults = [
                { title: `Fact-Check: Is "${query.substring(0, Math.min(query.length, 30))}" True?`, url: `https://www.reputable-news.com/fact-check?q=${encodeURIComponent(query)}` },
                { title: `Expert Analysis on "${query.substring(0, Math.min(query.length, 30))}"`, url: `https://www.academic-journal.org/analysis?q=${encodeURIComponent(query)}` },
                { title: `Breaking News: "${query.substring(0, Math.min(query.length, 30))}" - The Full Story`, url: `https://www.major-news-outlet.com/story?q=${encodeURIComponent(query)}` },
                { title: `Understanding the Context of "${query.substring(0, Math.min(query.length, 30))}"`, url: `https://www.thinktank.org/context?q=${encodeURIComponent(query)}` }
            ];

            return dummyResults;
        }


        document.getElementById('analyzeBtn').addEventListener('click', async function() {
            const newsInput = document.getElementById('newsInput').value;
            const analyzeBtn = document.getElementById('analyzeBtn');
            const deepDiveOutput = document.getElementById('deepDiveOutput');
            const propagandaPatterns = document.getElementById('propagandaPatterns');
            const verifiedCounterpoints = document.getElementById('verifiedCounterpoints');
            const counterNarrativeOutput = document.getElementById('counterNarrative');
            const deepfakeDetectionOutput = document.getElementById('deepfakeDetection');
            const sentimentGraphContainer = document.getElementById('sentimentGraph');


            if (newsInput.trim() === '') {
                showMessageBox('Please enter some news text or a link to analyze.');
                return;
            }

            // Show loading state for all sections
            analyzeBtn.innerHTML = '<span class="spinner"></span> Analyzing...';
            analyzeBtn.disabled = true;
            deepDiveOutput.innerHTML = '<p class="text-gray-500">Analyzing text, please wait...</p>';
            propagandaPatterns.innerHTML = '<p class="text-gray-500">Detecting patterns...</p>';
            verifiedCounterpoints.innerHTML = '<p class="text-gray-500">Searching for verified counterpoints...</p>';
            counterNarrativeOutput.innerHTML = '<p class="text-gray-500">Generating counter-narrative...</p>';
            deepfakeDetectionOutput.innerHTML = '<p class="text-gray-500">Checking for AI-generated text...</p>';
            sentimentGraphContainer.innerHTML = '<p class="text-gray-500">Generating sentiment graph...</p>'; // Clear for chart


            // Simulate analysis results for progress bars (these remain random for now)
            const confidenceScoreFill = document.querySelector('#confidenceScore .progress-bar-fill');
            const trustScoreFill = document.querySelector('#trustScore .progress-bar-fill');
            const communityConsensusFill = document.querySelector('#communityConsensus .progress-bar-fill');

            const randomConfidence = Math.floor(Math.random() * 101); // 0-100
            const randomTrust = Math.floor(Math.random() * 101); // 0-100
            const randomCommunity = Math.floor(Math.random() * 101); // 0-100

            // Apply appropriate class based on score for visual feedback
            function updateProgressBar(element, score, isCommunity = false) {
                element.style.width = `${score}%`;
                element.textContent = `${score}%`;
                element.classList.remove('score-low', 'score-medium', 'score-high', 'score-community');
                if (isCommunity) {
                    element.classList.add('score-community');
                } else if (score < 40) {
                    element.classList.add('score-low');
                } else if (score < 75) {
                    element.classList.add('score-medium');
                } else {
                    element.classList.add('score-high');
                }
            }

            updateProgressBar(confidenceScoreFill, randomConfidence);
            updateProgressBar(trustScoreFill, randomTrust);
            updateProgressBar(communityConsensusFill, randomCommunity, true);

            // Simulate sentiment data for the graph
            const simulatedSentimentData = [
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100),
                Math.floor(Math.random() * 100)
            ];
            // Ensure the canvas element is present before updating the graph
            sentimentGraphContainer.innerHTML = '<canvas id="mySentimentChart"></canvas>';
            updateSentimentGraph(simulatedSentimentData);


            // Perform all AI analysis and Google Search concurrently
            const [analysisResult, searchResults, aiDetectionResult] = await Promise.all([
                analyzeTextWithGemini(newsInput),
                performGoogleSearch(newsInput.substring(0, 100)), // Use a snippet of the input for search query
                detectAIText(newsInput) // Call AI text detection
            ]);

            // Update Explainable AI Auditor and Propaganda Pattern Recognizer
            const deepDiveRegex = /Deep Dive Analysis:([\s\S]*?)(?=Propaganda Patterns Detected:|$)/;
            const propagandaRegex = /Propaganda Patterns Detected:([\s\S]*)/;

            const deepDiveMatch = analysisResult.match(deepDiveRegex);
            const propagandaMatch = analysisResult.match(propagandaRegex);

            if (deepDiveMatch && deepDiveMatch[1]) {
                deepDiveOutput.innerHTML = `<p class="text-gray-800">${deepDiveMatch[1].trim().replace(/\n/g, '<br>')}</p>`;
            } else {
                deepDiveOutput.innerHTML = `<p class="text-gray-800">Deep Dive Analysis: ${analysisResult.replace(/\n/g, '<br>')}</p>`;
            }

            if (propagandaMatch && propagandaMatch[1]) {
                propagandaPatterns.innerHTML = `<p class="text-gray-800">${propagandaMatch[1].trim().replace(/\n/g, '<br>')}</p>`;
            } else if (!deepDiveMatch) {
                propagandaPatterns.innerHTML = `<p class="text-gray-800">Propaganda Patterns Detected: No specific patterns identified or analysis was general.</p>`;
            }

            // Update Verified Counterpoints (Google Search)
            if (searchResults && searchResults.length > 0) {
                let resultsHtml = '<p class="text-gray-800">Highly relevant and reputable news articles:</p><ul class="list-disc list-inside mt-3 text-base text-gray-600 space-y-1">';
                searchResults.forEach(result => {
                    resultsHtml += `<li><a href="${result.url}" target="_blank" class="text-gray-700 hover:underline hover-effect-link font-medium">${result.title}</a></li>`;
                });
                resultsHtml += '</ul>';
                verifiedCounterpoints.innerHTML = resultsHtml;
            } else {
                verifiedCounterpoints.innerHTML = '<p class="text-gray-800">No verified counterpoints found for this topic.</p>';
            }

            // Generate and update Counter-Narrative
            const counterNarrativeText = await generateCounterNarrative(newsInput, analysisResult);
            counterNarrativeOutput.innerHTML = `<p class="text-gray-800">${counterNarrativeText.replace(/\n/g, '<br>')}</p>`;

            // Update Deepfake & AI-Generated Text Detector
            deepfakeDetectionOutput.innerHTML = `<p class="text-gray-800">${aiDetectionResult.replace(/\n/g, '<br>')}</p>`;

            // Save analyzed article to user's history if logged in (not anonymous)
            if (window.authInstance.currentUser && !window.authInstance.currentUser.isAnonymous) {
                try {
                    await window.addDoc(window.collection(window.db, `artifacts/${window.appId}/users/${window.currentUserId}/analyzedArticles`), {
                        text: newsInput.substring(0, 500), // Save a snippet or full text
                        analysisSummary: analysisResult.substring(0, 200), // Save a summary
                        timestamp: window.serverTimestamp()
                    });
                    console.log("Analyzed article saved to user history.");
                } catch (error) {
                    console.error("Error saving analyzed article to user history:", error);
                }
            }


            // Reset button state
            analyzeBtn.innerHTML = 'Check News';
            analyzeBtn.disabled = false;
        });

        document.getElementById('addEvidenceBtn').addEventListener('click', async function() {
            const evidenceLink = document.getElementById('evidenceLinkInput').value.trim();
            const evidenceComment = document.getElementById('evidenceCommentInput').value.trim();

            if (!evidenceLink || !evidenceComment) {
                showMessageBox('Please provide both a link and a comment for your evidence.');
                return;
            }

            // Access Firebase instances from the global window object
            const db = window.db;
            const addDoc = window.addDoc;
            const collection = window.collection;
            const serverTimestamp = window.serverTimestamp;
            const appId = window.appId;
            const currentUserId = window.currentUserId;
            const doc = window.doc;
            const updateDoc = window.updateDoc;
            const getDoc = window.getDoc;
            const setDoc = window.setDoc;

            // IMPORTANT: Only allow authenticated (non-anonymous) users to submit evidence
            if (!window.authInstance.currentUser || window.authInstance.currentUser.isAnonymous) {
                showMessageBox('Please sign up or log in with an email account to submit evidence.');
                return;
            }


            if (!db || !addDoc || !collection || !serverTimestamp || !appId || !currentUserId || !doc || !updateDoc || !getDoc || !setDoc) {
                console.error("Firebase services not fully initialized or user not authenticated.");
                showMessageBox("Error: Firebase services not ready. Please try again.");
                return;
            }

            try {
                // Add contribution to public collection
                await addDoc(collection(db, `artifacts/${appId}/public/data/communityContributions`), {
                    link: evidenceLink,
                    comment: evidenceComment,
                    userId: currentUserId,
                    timestamp: serverTimestamp(),
                    points: 10 // Award 10 points for each contribution
                });

                // Update user's points
                const userDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/profile/data`);
                const userDocSnap = await getDoc(userDocRef);
                let currentPoints = 0;
                if (userDocSnap.exists()) {
                    currentPoints = userDocSnap.data().points || 0;
                    await updateDoc(userDocRef, { points: currentPoints + 10 });
                } else {
                    // This case should ideally not happen if onAuthStateChanged works, but as a fallback
                    await setDoc(userDocRef, { points: 10, createdAt: serverTimestamp() });
                }
                window.userPoints = currentPoints + 10; // Update global points
                document.getElementById('currentUserPointsDisplay').textContent = `Your Points: ${window.userPoints}`;


                showMessageBox('Evidence submitted successfully! You earned 10 points.');
                document.getElementById('evidenceLinkInput').value = '';
                document.getElementById('evidenceCommentInput').value = '';
            } catch (error) {
                console.error("Error submitting evidence or updating points:", error);
                showMessageBox("Error submitting evidence. Please try again.");
            }
        });


        document.getElementById('sendChatBtn').addEventListener('click', async function() {
            const chatInput = document.getElementById('chatInput');
            const chatWindow = document.getElementById('chatWindow');
            const userMessage = chatInput.value.trim();

            if (userMessage === '') {
                return;
            }

            // Add user message to chat window
            const userDiv = document.createElement('div');
            userDiv.className = 'text-right mb-3';
            userDiv.innerHTML = `<span class="font-semibold text-gray-700">You:</span> ${userMessage}`;
            chatWindow.appendChild(userDiv);

            // Show loading for bot response
            const botDiv = document.createElement('div');
            botDiv.className = 'text-left mb-3';
            botDiv.innerHTML = `<span class="font-semibold text-gray-700">Bot:</span> <span class="spinner"></span> Thinking...`;
            chatWindow.appendChild(botDiv);

            chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom

            chatInput.value = ''; // Clear input

            // Simulate bot response with Gemini API call for fact-checking
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: `Act as a helpful and concise fact-checking bot. Provide an instant assessment in natural language for the following query or text. If relevant, proactively ask if the user wants to see how reputable news sources are covering this, and if so, suggest a Google Search link.
            
            User query/text: "${userMessage}"` }] });

            const payload = { contents: chatHistory };
            // Use the API key from firebaseConfig
            const apiKey = window.firebaseConfig.apiKey; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error('Gemini API HTTP Error (Chat Bot):', response.status, errorBody);
                    botDiv.innerHTML = `<span class="font-semibold text-gray-700">Bot:</span> Error: Fact-check service failed with status ${response.status}.`;
                    return;
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const botResponseText = result.candidates[0].content.parts[0].text;
                    // Replace the loading spinner with the actual response
                    botDiv.innerHTML = `<span class="font-semibold text-gray-700">Bot:</span> ${botResponseText.replace(/\n/g, '<br>')}`;
                } else {
                    botDiv.innerHTML = `<span class="font-semibold text-gray-700">Bot:</span> Error: Could not get a response from the fact-check bot.`;
                    console.error('Gemini API response structure unexpected for chat bot:', result);
                }
            } catch (error) {
                botDiv.innerHTML = `<span class="font-semibold text-gray-700">Bot:</span> Error: Failed to connect to the fact-check bot service.`;
                console.error('Error calling Gemini API for chat bot:', error);
            } finally {
                chatWindow.scrollTop = chatWindow.scrollHeight; // Scroll to bottom again
            }
        });

        // Allow pressing Enter to send chat message
        document.getElementById('chatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('sendChatBtn').click();
            }
        });

        // Logout button event listener
        document.getElementById('logoutButton').addEventListener('click', async () => {
            try {
                await window.signOut(window.authInstance); // Use the globally exposed signOut and authInstance
                // Redirect to auth.html after successful logout
                window.location.href = 'auth.html';
            } catch (error) {
                console.error("Error logging out:", error);
                showMessageBox(`Error logging out: ${error.message}`);
            }
        });
    </script>
</body>
</html>
